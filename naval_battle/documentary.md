﻿﻿ Создание нашей программы началось с выбора игры: мы хотели сделать примитивный шутер, но, как выяснилось, анимация была под запретом и поэтому наш выбор пал на первое, что мы вспомнили: "Морской бой". **Морской бой** — это игра для двух участников, в которой они сначала придумывают расположение для своих кораблей на своём поле, а затем по очереди пытаются уничтожить корабли соперника, называя координаты на неизвестной им карте соперника. Если у соперника по этим координатам имеется корабль, то он, или его часть, «топится», а попавший получает право сделать ещё один ход. Цель игрока — первым потопить все корабли противника.Первая проблема в разработке появилась в самом начале: мы не могли решить в какой среде разработки будем работать. QT Creator имел преимущество в простоте использования библиотеки Graph_lib, но Visual Studio привычнее и удобнее в оформлении кода. После долгих ссор и переговоров выбор пал на VS.Затем каждому была дана своя задача: один занимается полем и общей "внутренней" составляющей игры, другой отвечает за дизайн и вывод "внутренней" составляющей, третий занимался тестированием и ведением GIT'a. Каждый этап создания обсуждался, между нами, до тех пор, пока мы не приходили к компромиссу. Например, вначале у нас была ~~отличная~~ идея создать поле 12 на 12 для облегчения проверки правильности координат выставляемых кораблей, но позже стало понятно, что это требует слишком много усилий и сложно в реализации. В конце концов мы пришли к конечной версии: полю 10х10, в котором после расположения кораблей "блокируются" соседние клетки.Следующим предметом спора было то, как пользователь будет выставлять свои корабли в начале игры. У нас было три разных варианта: перетаскивать корабли с панели сбоку, нажимать на клетки поля или напрямую задавать с помощью координат, вводя их в отдельное окошко. Первый вариант сразу отпал, ввиду сложности реализации. Далее между нами завязался долгий спор: взаимодействие с клетками поля интерактивно и удобно для пользователя, третий же вариант выглядит ~~ущербно~~ некрасиво и менее понятен, но упрощает проверку расположения и ~~мучения~~ настройку кнопок.Также немало вопросов было по поводу дизайна. Как будет выглядеть начальное меню? Как будет выглядеть экран задания координат кораблей? А в процессе игры? Может, каждому игроку показывать во время его хода только поле противника, а может и свое поле? Или вообще не делать разных окон для каждого игрока и расположить два поля в одном окне (то есть каждый игрок сразу видит два поля, и свое, и противника).  В меню было решено сделать просто режимы с выбором игры и отдельную кнопку для вывода правил. В процессе игры же окна для каждого игрока были разделены. После того, как один игрок сделал ход, окно меняется (в окне только одно поле), в связи с более простой реализацией.Также мы постарались сделать наш дизайн отличным от других похожих игр, поэтому подумали, что было бы неплохо говорить пользователю обо всех ошибках, возникающих в процессе. Так что, после всех споров мы наконец пришли к финальному виду нашего окна: сверху были кнопки введения координат и "передачи" хода, посередине - само поле, а справа от него небольшая консоль с отчетами об ошибках. Итак, половина работы с модельками закончена, так что можно приступить к созданию моделей кораблей, текстур воды и попаданий. Но это уже другая история...Наш начальный план был идеален и не допускал промахов: мы хотели спокойно скопировать модельки из интернета и забить на корабли. Но, не тут-то было, ехидные форматы изображений так не думали. Как оказалось, графическая библиотека поддерживала два формата: .jpg и .gif. Но и тут не обошлось без подвоха: .jpg не поддерживал невидимый задний фон, а подставлял свой собственный серый, а .gif не отображался корректно, а "смазывался" и был виден неотчетливо или вообще распадался на пиксели. После недели размышлений и попыток настроить библиотеку, нами было принято решение совместить текстуры моря и текстуры кораблей. Таким образом из графической составляющей нам оставалось лишь придумать текстуру моря и нарисовать корабли. Закончив с этим, мы приступили к самому ~~мерзкому~~ приятному - прорабатыванию плана расположения кнопок и их настройке.Долгое время мы не могли решить, как хотим хранить кнопки: в виде двумерного массива или иметь для каждой кнопки поля индивидуальный идентификатор. От этого зависело как мы будем создавать поле: в отдельном классе Cell создавать отдельные клетки и соединять их в единое целое или хранить все поле как целое и взаимодействовать уже с ним. У каждого варианта свои плюсы: например, раздельное создание клеток позволяет контролировать функции каждой отдельной клетки, но тратит гораздо больше времени и ресурсов, чем обыкновенное создание общего поля. В общем, обдумав все стороны этого решения, мы поняли, что создание единого поля удобнее и с ним легче работать.Спустя несколько недель создания кода наконец появилась первая версия. Да, она была не идеальна: у нас были слишком сжатые модельки, не было консоли ошибок, и мы не знали, как будем передавать доступ к полю следующему игроку. Но поле уже создавалось и на него ставились корабли, а это уже маленькая победа!!!Также мы так и не смогли придумать как будем передавать положение кораблей для следующего игрока, наш старый алгоритм не работал с координатами правильно и не передавал вообще ничего. Мы исправили это с помощью цикла, счетчика, который определял чей сейчас ход, и пары функций, скрывающих экран прошлого игрока и показывающих новый. После попытки создания рандомной генерации расположения также возникли проблемы: из-за неправильного алгоритма наши корабли могли создаваться, где угодно, даже за пределами поля. Проблема была в том, что мы для проверки точки создавали образ корабля, но после неверной проверки не удаляли его, а забывали тем самым засоряя место. Решение было очень простым, мы просто стали проверять в цикле точку, не создавая “фантомных” кораблей.Итак, еще через пару недель у нас имелась уже рабочая программа с двумя разными окнами, работающим случайным расположением, а также уже гораздо более приятным интерфейсом. Но, начав проверки, мы поняли, что обведение уничтоженного корабля точками (для удобства пользователя клетки вокруг корабля помечались, так как кораблей там быть не могло) работает не во всех случаях, например на краях поля. И хотя казалось, что на обнаружение ошибки должно уйти немного времени, на деле все оказалось сложно и запутанно, и ошибка обработки внутри цикла обнаружилась далеко не сразу. Она исправлялась очень просто, но так сильно влияла на игру.После всех этих исправлений настолько больших и “влиятельных” ошибок больше не было. Так что, после некоторых мелких изменений в дизайне и перерисовке моделей под маленькое разрешение, мы решили дать протестировать игру кому-то, кто не имел к ее созданию отношения. Претендент нашелся очень быстро, и, как оказалось, он уже имел подобный опыт в прошлом, поэтому знал, что и где искать. В качестве проверяющего мы взяли физика, закончившего биологический класс и умевшего программировать (по словам автора) на HTML (то есть идеальный тестер, подстраивающийся под любой уровень развития). Мы давали ему игру с полной уверенностью в том, что мы обработали основные ошибки. Но его опыт дал о себе знать, и он нашел то, о чем было даже сложно подумать. Например, мы совсем забыли о контроле количества выставляемых кораблей, и он выставил целых 4 трехпалубных корабля, тогда как по правилам они ограничены тремя. В общем, опыт использования сторонних тестировщиков оказался очень успешным и полезным, так как игра наконец была приведена в полностью рабочее состояние и готова к сдаче.